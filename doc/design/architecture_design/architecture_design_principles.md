# 旅行信息分享应用架构设计原则

## 1. 引言

本文档详细阐述了“旅行信息分享应用”的软件架构设计原则。本项目采用**领域驱动设计**作为核心指导思想，结合**分层架构**模式，旨在构建一个高内聚、低耦合、易于维护和扩展的系统。

本架构设计主要解决以下核心问题：
*   **业务复杂性管理**：通过限界上下文划分，将复杂的旅行分享业务拆解为可管理的模块。
*   **技术与业务解耦**：保证核心业务逻辑不依赖于具体的数据库、Web 框架或外部 API。
*   **团队协作与规范**：为前后端开发、数据库设计及 AI 功能集成提供统一的代码组织标准。

---

## 2. 核心架构风格：领域驱动设计

本项目不采用传统的 MVC（Model-View-Controller）架构，而是采用更为严谨的 DDD 分层架构。核心理念是将业务逻辑（Domain）作为系统的核心，一切技术实现（UI, Database, API）都围绕业务逻辑展开。

### 2.1 限界上下文

为了明确业务边界，我们将系统划分为五个独立的限界上下文。每个上下文内部保持高度自治，上下文之间通过定义良好的接口或事件进行交互。

1.  **用户认证上下文**
    *   **职责**：负责身份识别与访问控制。
    *   **核心模型**：User, Role, Permission.
    *   **边界**：为其他所有模块提供当前操作用户的身份信息。

2.  **旅行核心上下文**
    *   **职责**：系统的核心业务，处理行程规划、路线管理。
    *   **核心模型**：Trip (聚合根), TripDay, Activity, Transit.
    *   **边界**：行程数据的唯一写入点，对外发布行程变更事件。

3.  **社交互动上下文**
    *   **职责**：处理用户间的交互、内容分享与即时通讯。
    *   **核心模型**：Post (聚合根), Comment, Conversation (聚合根), Message.
    *   **边界**：依赖 Auth 上下文获取用户信息，引用 Travel 上下文的行程 ID（弱关联）。

4.  **AI 智能助手上下文**
    *   **职责**：提供基于 RAG 的智能问答服务。
    *   **核心模型**：AiConversation, AiMessage.
    *   **边界**：作为独立服务，只读访问其他上下文的数据用于构建知识库上下文。

5.  **后台管理上下文**
    *   **职责**：系统级资源管理与监控。
    *   **边界**：拥有跨上下文的超级权限，直接操作各模块的基础设施层数据。

---

## 3. 分层架构设计

在每个限界上下文内部，我们严格遵循**四层架构**。每一层只能依赖于它的直接下层（或更内层），严禁跨层依赖或反向依赖。

### 3.1 接口层
*   **位置**：`app_<module>/view/`
*   **职责**：
    *   作为系统的“门户”，处理 HTTP 请求与 WebSocket 连接。
    *   解析前端传入的 JSON 数据，进行初步的格式校验（DTO 验证）。
    *   调用应用层服务（Application Service）执行业务操作。
    *   将业务处理结果（Domain Object 或 DTO）转换为 HTTP 响应格式（JSON）。
*   **原则**：接口层**不包含任何业务逻辑**。它只负责“翻译”和“传递”。
*   **技术实现**：Flask Blueprints, Flask-SocketIO Event Handlers.

### 3.2 应用层
*   **位置**：`app_<module>/services/`
*   **职责**：
    *   **编排业务流程**：它不处理具体的业务规则，而是指挥领域对象和基础设施服务协同工作。
    *   **事务控制**：定义业务操作的原子性（Transaction Boundary）。确保一个用例（Use Case）要么全部成功，要么全部回滚。
    *   **依赖注入**：组装 Repository、Domain Service 等组件。
    *   **事件发布**：在业务操作完成后，将领域层产生的 Domain Events 发布到事件总线。
*   **原则**：应用层应该保持**轻量级**。如果有复杂的条件判断，应该下沉到领域层。
*   **代码示例**：`TravelService.create_trip()`

### 3.3 领域层 —— 系统的心脏
*   **位置**：`app_<module>/domain/`
*   **职责**：
    *   封装核心业务逻辑、状态校验规则、业务计算逻辑。
    *   **纯粹性**：绝不依赖数据库、Web 框架、外部 API。它是纯 Python 代码。
*   **核心组件**：
    *   **聚合与聚合根**：保证数据一致性的最小单元。例如 `Trip` 是聚合根，管理 `TripDay` 和 `Activity` 的生命周期。任何对内部实体的修改必须通过聚合根方法（如 `trip.add_activity()`）。
    *   **实体**：有唯一标识的对象。
    *   **值对象**：无标识，通过属性定义的对象（如 `Money`, `DateRange`），通常设计为不可变。
    *   **领域服务**：处理跨实体的逻辑（如 `ItineraryService` 计算路线）。
    *   **仓储接口**：定义数据存取的抽象契约（如 `ITripRepository`），具体实现由基础设施层提供。
*   **设计模式**：采用**充血模型**，拒绝贫血模型。业务逻辑应封装在实体的方法中，而不是散落在 Service 层。

### 3.4 基础设施层
*   **位置**：`app_<module>/infrastructure/`
*   **职责**：
    *   提供所有上层所需的具体技术实现。
    *   **持久化**：实现领域层的 Repository 接口（`RepositoryImpl`），使用 DAO 操作数据库。
    *   **外部服务适配**：封装第三方 API（如高德地图、DeepSeek LLM）。
    *   **对象映射**：定义持久化对象 (PO) 并处理 PO 与 Domain Entity 之间的转换 (Mapper)。
*   **技术实现**：SQLAlchemy Models (PO), PyMySQL, Requests, LangChain。

---

## 4. 数据持久化策略

为了保持领域层的纯洁性，我们采用了**PO + Repository + DAO** 的组合模式。

### 4.1 持久化对象 vs 领域实体
*   **PO (`*PO`)**：直接对应数据库表结构。包含外键、数据库特有的数据类型。位于基础设施层。
*   **Domain Entity**：对应业务概念。包含业务行为。位于领域层。
*   **分离的意义**：数据库表结构的变更不应直接影响业务逻辑代码；反之亦然。这允许我们独立演化数据库设计和业务模型。

### 4.2 仓储模式
Repository 是领域层和基础设施层的连接点。
*   **接口**：在 Domain 层定义（如 `find_by_id`, `save`）。
*   **实现**：在 Infrastructure 层实现。实现类负责调用 DAO 获取 PO，然后通过 Mapper 将 PO 转换为 Entity 返回给领域层。

### 4.3 数据访问对象
DAO 封装了具体的 SQLAlchemy 查询逻辑。它只认识 PO，不认识 Domain Entity。它负责处理复杂的 SQL 拼接、分页查询、多表关联等。

---

## 5. 关键技术决策与选型理由

### 5.1 后端：Python Flask
*   **选型理由**：Flask 是一个微框架，极其轻量且不强制特定的项目结构。这使得我们能够自由地按照 DDD 的规范去搭建目录结构，而不是被框架的约定束缚（如 Django 的 MVT）。
*   **适用性**：Python 在 AI 领域的统治地位使得集成 DeepSeek 和 LangChain 变得非常原生和顺滑。

### 5.2 数据库：MySQL + SQLAlchemy
*   **选型理由**：本应用的数据（用户、行程、交易、关系）具有高度的结构化特征和强一致性需求，关系型数据库是最佳选择。
*   **ORM**：SQLAlchemy 是 Python 生态中最强大的 ORM，支持 Data Mapper 模式，非常契合 DDD 中实体与表分离的需求。

### 5.3 前端：React.js
*   **选型理由**：React 的组件化思想非常适合构建复杂的交互界面（如拖拽排程、地图交互）。单页应用架构配合 RESTful API，实现了前后端的完全解耦，允许并行开发。

### 5.4 AI 集成：DeepSeek + RAG
*   **选型理由**：DeepSeek 提供了高性能的大语言模型能力。结合 RAG (检索增强生成) 技术，利用本地数据库（Activity, Trip, Post）作为知识库，解决了通用大模型在特定旅行场景下“幻觉”严重的问题，提供了精准的个性化建议。

---

## 6. 跨切面关注点 (Cross-Cutting Concerns)

### 6.1 异常处理
系统定义了统一的异常基类 `AppException`。所有业务层面的错误（如“行程不存在”、“权限不足”）都抛出特定的领域异常。接口层通过 Flask 的 `errorhandler` 统一捕获这些异常，并转换为标准化的 JSON 错误响应（包含 `error_code` 和 `message`）。

### 6.2 事务管理
事务边界通常划定在**应用服务层 (Application Service)** 的方法级别。一个 Service 方法对应一个数据库事务。我们使用 Flask 的 `g` 对象或装饰器来管理 Session 的生命周期，确保请求结束时自动提交或回滚。

### 6.3 领域事件 (Domain Events)
为了解耦不同限界上下文，我们引入了轻量级的事件总线。
*   **产生**：聚合根在执行状态变更操作时，生成事件对象（如 `TripMemberAddedEvent`）。
*   **分发**：Service 层提交事务前/后，将事件发布到 EventBus。
*   **消费**：独立的 Handler 订阅事件。例如，当 `MessageSentEvent` (社交域) 发生时，SocketIO Handler 监听到该事件并将消息推送到前端。

---

## 7. 总结

本架构设计的核心目标是**“控制复杂度”**。通过将技术实现细节隔离在基础设施层，我们将最宝贵的开发精力集中在领域层，确保业务逻辑的正确性和灵活性。虽然这种分层架构在初期会引入一定的代码量（如 PO 与 Entity 的转换），但它为项目的长期维护、测试和功能扩展提供了坚实的基础。
